// backend/db/schema.ts
import {
  pgTable,
  serial,
  text,
  integer,
  timestamp,
  uniqueIndex,
  uuid, // Import uuid type for generating UUIDs
} from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";

/**
 * Schema for the 'polls' table.
 * Stores the details of each 'Would You Rather?' poll.
 * Now supports up to four answer options, includes a unique slug,
 * and maintains a count of associated comments.
 */
export const polls = pgTable("polls", {
  // Primary key, now a UUID. This will be generated using the 'uuid-ossp' extension.
  id: uuid("id").primaryKey().defaultRandom(), // Changed from serial to uuid, and added defaultRandom()
  // The main question of the poll.
  question: text("question").notNull(),
  // A unique, URL-friendly identifier derived from the question.
  // This needs to be generated by your application logic before insertion.
  slug: text("slug").notNull().unique(), // New slug attribute, must be unique
  // Text for the first option.
  optionA_text: text("option_a_text").notNull(),
  // Text for the second option.
  optionB_text: text("option_b_text").notNull(),
  // Text for the third option. Nullable, allowing for polls with 2 or 3 options.
  optionC_text: text("option_c_text"),
  // Text for the fourth option. Nullable, allowing for polls with 2 or 3 options.
  optionD_text: text("option_d_text"),
  // Current vote count for option A. Defaults to 0.
  optionA_votes: integer("option_a_votes").notNull().default(0),
  // Current vote count for option B. Defaults to 0.
  optionB_votes: integer("option_b_votes").notNull().default(0),
  // Current vote count for option C. Defaults to 0.
  optionC_votes: integer("option_c_votes").notNull().default(0),
  // Current vote count for option D. Defaults to 0.
  optionD_votes: integer("option_d_votes").notNull().default(0),
  // New field: Count of comments for this poll. Defaults to 0.
  comments_count: integer("comments_count").notNull().default(0),
  // Timestamp when the poll was created. Defaults to the current timestamp.
  createdAt: timestamp("created_at").defaultNow().notNull(),
  // Timestamp when the poll was last updated. Can be null initially.
  updatedAt: timestamp("updated_at")
    .defaultNow()
    .$onUpdate(() => new Date())
    .notNull(),
});

/**
 * Relations for the 'polls' table.
 * A poll can have many anonymous votes, many comments, and many topics associated with it.
 */
export const pollsRelations = relations(polls, ({ many }) => ({
  anonymousVotes: many(anonymousVotes),
  comments: many(comments), // A poll can have many comments
  pollTopics: many(pollTopics), // A poll can have many topics through the join table
}));

/**
 * Schema for the 'anonymous_votes' table.
 * Used for basic vote limiting to prevent multiple votes from the same anonymous user
 * on a single poll. The 'voter_identifier' could be an IP address or a session ID.
 */
export const anonymousVotes = pgTable(
  "anonymous_votes",
  {
    // Primary key for the vote record, now a UUID.
    id: uuid("id").primaryKey().defaultRandom(), // Changed from serial to uuid
    // Foreign key referencing the 'id' (UUID) of the 'polls' table.
    pollId: uuid("poll_id")
      .notNull()
      .references(() => polls.id),
    // An identifier for the anonymous voter (e.g., IP address, simple session token).
    // This helps in preventing multiple votes from the same source.
    voterIdentifier: text("voter_identifier").notNull(),
    // New field: Stores which option (A, B, C, or D) the user chose.
    chosenOption: text("chosen_option").notNull(), // Added chosen_option field
    // Timestamp when the vote was cast.
    createdAt: timestamp("created_at").defaultNow().notNull(),
  },
  (table) => [
    // Ensures that a unique combination of pollId and voterIdentifier exists.
    // This prevents the same anonymous user from voting more than once on the same poll.
    uniqueIndex("poll_id_voter_identifier_idx").on(
      table.pollId,
      table.voterIdentifier
    ),
  ]
);

/**
 * Relations for the 'anonymous_votes' table.
 * An anonymous vote belongs to one poll.
 */
export const anonymousVotesRelations = relations(anonymousVotes, ({ one }) => ({
  poll: one(polls, {
    fields: [anonymousVotes.pollId],
    references: [polls.id],
  }),
}));

/**
 * Schema for the 'comments' table.
 * Stores anonymous comments associated with a specific poll.
 * Now supports a hierarchical structure for threaded comments.
 */
// @ts-ignore
export const comments = pgTable("comments", {
  // Primary key, now a UUID.
  id: uuid("id").primaryKey().defaultRandom(), // Changed from serial to uuid, and added defaultRandom()
  // Foreign key referencing the 'id' (UUID) of the 'polls' table.
  pollId: uuid("poll_id")
    .notNull()
    .references(() => polls.id),
  // Foreign key for parent comment, allowing for threaded discussions.
  // Nullable, as top-level comments will not have a parent.
  // @ts-ignore
  parentId: uuid("parent_id").references(() => comments.id),
  // The actual text content of the comment.
  commentText: text("comment_text").notNull(),
  // Timestamp when the comment was created. Defaults to the current timestamp.
  createdAt: timestamp("created_at").defaultNow().notNull(),
  // Optional: An identifier for the anonymous commenter.
  voterIdentifier: text("voter_identifier"),
});

/**
 * Relations for the 'comments' table.
 * A comment belongs to one poll and can have a parent and multiple children comments.
 */
export const commentsRelations = relations(comments, ({ one, many }) => ({
  poll: one(polls, {
    fields: [comments.pollId],
    references: [polls.id],
  }),
  // A comment can have one parent comment.
  // @ts-ignore
  parent: one(() => comments, {
    fields: [comments.parentId],
    references: [comments.id],
    relationName: "parentComment", // Unique relation name for self-referencing
  }),
  // A comment can have many children comments.
  // @ts-ignore
  children: many(() => comments, {
    relationName: "parentComment", // Use the same relation name to link children back to parent
  }),
}));

/**
 * Schema for the 'topics' table.
 * Stores unique topic names and slugs for categorization.
 */
export const topics = pgTable("topics", {
  id: uuid("id").primaryKey().defaultRandom(), // UUID primary key
  name: text("name").notNull().unique(), // The topic name (e.g., 'Politics')
  slug: text("slug").notNull().unique(), // URL-friendly slug (e.g., 'politics')
});

/**
 * Relations for the 'topics' table.
 * A topic can be associated with many polls through the join table.
 */
export const topicsRelations = relations(topics, ({ many }) => ({
  pollTopics: many(pollTopics),
}));

/**
 * Schema for the 'poll_topics' join table.
 * Establishes a many-to-many relationship between polls and topics.
 */
export const pollTopics = pgTable(
  "poll_topics",
  {
    pollId: uuid("poll_id")
      .notNull()
      .references(() => polls.id),
    topicId: uuid("topic_id")
      .notNull()
      .references(() => topics.id),
  },
  (table) => [
    // Ensures a unique combination of poll and topic to prevent duplicate associations
    uniqueIndex("poll_topic_idx").on(table.pollId, table.topicId),
  ]
);

/**
 * Relations for the 'poll_topics' join table.
 * Links a poll to a topic.
 */
export const pollTopicsRelations = relations(pollTopics, ({ one }) => ({
  poll: one(polls, {
    fields: [pollTopics.pollId],
    references: [polls.id],
  }),
  topic: one(topics, {
    fields: [pollTopics.topicId],
    references: [topics.id],
  }),
}));
